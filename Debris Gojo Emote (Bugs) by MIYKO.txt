--DEBRIS (INTENTO DE EFECTO DE EMOTE DE GOJO [SALE MAL XD])

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Configuración
local DEBRIS_COUNT = 12       -- cuántos cubos
local RANGE_MIN = 10          -- distancia mínima del jugador
local RANGE_MAX = 25          -- distancia máxima del jugador
local FLOAT_HEIGHT = 5        -- altura base de flotación
local SPEED = 0.2             -- ⚡ aún más lento
local ROCK_SIZE = 1.2         -- tamaño de cada cubo

local debrisParts = {}

-- Crear todos los cubos solo una vez
local function createDebris()
	for i = 1, DEBRIS_COUNT do
		local p = Instance.new("Part")
		p.Anchored = true
		p.CanCollide = false
		p.Color = Color3.fromRGB(110, 110, 110) -- gris tipo piedra/piso
		p.Material = Enum.Material.Concrete
		p.Size = Vector3.new(ROCK_SIZE, ROCK_SIZE, ROCK_SIZE)
		p.Shape = Enum.PartType.Block
		p.Parent = workspace

		-- Guardar info inicial de cada cubo
		table.insert(debrisParts, {
			part = p,
			angle = math.random() * math.pi * 2,
			distance = math.random(RANGE_MIN, RANGE_MAX),
			heightOffset = math.random(-2, 3),
			tilt = Vector3.new(math.random(), math.random(), math.random())
		})
	end
end

-- Actualizar movimiento de los cubos
local function updateDebris()
	if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
	local hrp = LocalPlayer.Character.HumanoidRootPart
	local t = tick() * SPEED

	for _, d in ipairs(debrisParts) do
		local offsetX = math.cos(d.angle + t) * d.distance
		local offsetZ = math.sin(d.angle + t) * d.distance
		local floatY = FLOAT_HEIGHT + d.heightOffset + math.sin(t + d.angle) * 1.5

		-- Movimiento + rotación suave (sin teleports)
		d.part.CFrame = hrp.CFrame * CFrame.new(offsetX, floatY, offsetZ) 
			* CFrame.Angles(t * d.tilt.X * 0.1, t * d.tilt.Y * 0.1, t * d.tilt.Z * 0.1)
	end
end

-- Iniciar
createDebris()
RunService.RenderStepped:Connect(updateDebris)